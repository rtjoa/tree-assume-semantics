
\begin{figure}%{\linewidth}
  \begin{minipage}[t]{0.45\linewidth}
    \begin{grammar}

      <basetype> ::= IntT \alt BoolT

      <type> ::= <basetype> \alt PointerT <type> \alt TupleT <basetype>*

      <bool> ::= True \alt False


      <order> ::= Parallel \alt Sequential

      <function> ::= Function <type> <expr>

      <assumption> ::= InLet <expr>
      \alt InLoop <expr> <expr>
      \alt InFunc <function>
      \alt InSwitch <\N> <expr>
      \alt InIf <bool> <expr>



    \end{grammar}
  \end{minipage}\hfill%
  \begin{minipage}[t]{0.5\linewidth}
    \begin{grammar}
      <expr> ::= Arg <type>
      \alt Int <\N>
      \alt Bool <bool>
      \alt Empty
      \alt Add <expr> <expr>
      \alt Sub <expr> <expr>
      \alt Mul <expr> <expr>
      \alt LessThan <expr> <expr>
      \alt And <expr> <expr>
      \alt Or <expr> <expr>
      \alt Write <expr> <expr>
      %% \alt PtrAdd <expr> <expr>
      \alt Not <expr>
      \alt Print <expr>
      \alt Load <expr>
      \alt Get <expr> <\N>
      \alt Alloc <expr> <type>
      \alt Call <function> <expr>
      \alt Single <expr>
      \alt Concat <order> <expr> <expr>
      \alt Switch <expr> <expr>*
      \alt If <expr> <expr> <expr>
      \alt Let <expr> <expr>
      \alt DoWhile <expr> <expr>
      \alt Assume <assumption> <expr>
    \end{grammar}%
    \end{minipage}%
  \caption{expr abstract syntax.}
\end{figure}

\renewcommand{\inferrule}[3]{\infrule[#1]{\mbox{#2}}{\mbox{#3}}}
\newcommand{\bigstep}[2]{#1 $\Downarrow$ #2}
\newcommand{\ang}[1]{$\langle #1 \rangle$}
\newcommand{\spair}[2]{\ang{#1, #2}}
\newcommand{\strip}[3]{\ang{#1, #2, #3}}

\newcommand{\targ}{\alpha}
\newcommand{\tmem}{\sigma}


\clearpage
%% \begin{figure}
\newpage

\bigstep{\strip{e}{\targ}{\tmem}}{\spair{v}{\tmem'}} means: with argument $\targ$ and state $\tmem$, $e$ evaluates to $v$ and the resulting state is $\tmem'$.

A state is pair $(M, L)$, containing memory and a print log.

\inferrule{E-Add}{
  \bigstep{\strip{e_1}{\targ}{\sigma}}{\spair{v_1}{\sigma'}} \andalso
  \bigstep{\strip{e_2}{\targ}{\sigma'}}{\spair{v_2}{\sigma''}}
}
{\bigstep{
  \strip{\text{Add }e_1\ e_2}{\targ}{\sigma}
}{
  \spair{v_1 + v_2}{\sigma''}
}}

\inferrule{E-IfTrue}{
  \bigstep{\strip{c}{\targ}{\sigma}}{\spair{\top}{\sigma'}} \andalso
  \bigstep{\strip{t}{\targ}{\sigma'}}{\spair{v}{\sigma''}}
}
{\bigstep{
  \spair{\text{If }c\ t\ e}{\sigma}
}{
  \spair{v}{\sigma''}
}}

\inferrule{E-IfFalse}{
  \bigstep{\strip{c}{\targ}{\sigma}}{\spair{\bot}{\sigma'}} \andalso
  \bigstep{\strip{e}{\targ}{\sigma'}}{\spair{v}{\sigma''}}
}
{\bigstep{
  \spair{\text{If }c\ t\ e}{\sigma}
}{
  \spair{v}{\sigma''}
}}

\inferrule{E-Switch}{
  \bigstep{\strip{k}{\targ}{\sigma}}{\spair{i}{\sigma'}} \andalso
  \bigstep{\strip{e_i}{\targ}{\sigma'}}{\spair{v}{\sigma''}}
}
{\bigstep{
    \strip{\text{Switch }k\ (e_1, \dots, e_n)}{\targ}{\sigma}
  }{
    \spair{v}{\sigma''}
}}

\inferrule{E-Assume}{
  \bigstep{\strip{e}{\targ}{\sigma}}{\spair{v}{\sigma'}}
}
{\bigstep{
  \strip{\text{Assume }e\ a}{\targ}{\sigma}
}{
  \spair{v}{\sigma'}
}}

\inferrule{E-Let}{
  \bigstep{\strip{i}{\targ}{\sigma}}{\spair{\targ'}{\sigma'}} \andalso
  \bigstep{\strip{o}{\targ'}{\sigma'}}{\spair{v}{\sigma''}}
}
{\bigstep{
  \strip{\text{Let }i\ o}{\targ}{\sigma}
}{
  \spair{v}{\sigma''}
}}

\inferrule{E-Print}{
  \bigstep{\strip{e}{\targ}{\sigma}}{\spair{v}{(M, L)}} \andalso
}
{\bigstep{
  \strip{\text{Print }e}{\targ}{\sigma}
}{
  \spair{[]}{(M, L \texttt{ ++ } v)}
}}

\inferrule{E-Load}{
  \bigstep{\strip{e}{\targ}{\sigma}}{\spair{v}{(M, L)}} \andalso
}
{\bigstep{
  \strip{\text{Load }e}{\targ}{\sigma}
}{
  \spair{M[v]}{(M, L)}
}}

\inferrule{E-Alloc}{
  \bigstep{\strip{e}{\targ}{\sigma}}{\spair{v}{(M, L)}} \andalso
  $p$ = malloc(sizeof($\tau$))
}
{\bigstep{
  \strip{\text{Alloc }e\ \tau}{\targ}{\sigma}
}{
  \spair{p}{(M[p \to v], L)}
}}

\inferrule{E-Store}{
  \bigstep{\strip{p}{\targ}{\sigma}}{\spair{v_p}{\sigma'}} \andalso
  \bigstep{\strip{e}{\targ}{\sigma'}}{\spair{v_e}{(M, L)}} \andalso
}
{\bigstep{
    \strip{\text{Store }p\ e}{\targ}{\sigma}
  }{
    \spair{[]}{(M[v_p\to v_e], L)}
}}


\inferrule{E-Single}{
  \bigstep{\strip{e}{\targ}{\sigma}}{\spair{v}{\sigma'}}
}
{\bigstep{
    \strip{\text{Single }e}{\targ}{\sigma}
  }{
    \spair{[v]}{\sigma'}
}}


\inferrule{E-ConcatSeq}{
  \bigstep{\strip{e_1}{\targ}{\sigma}}{\spair{v_1}{\sigma'}} \andalso
  \bigstep{\strip{e_2}{\targ}{\sigma'}}{\spair{v_2}{\sigma''}} \andalso
}
{\bigstep{
    \strip{\text{Concat Sequential }e_1\ e_2}{\targ}{\sigma}
  }{
    \spair{v_1\texttt{ ++ }v_2}{\sigma''}
}}



\inferrule{E-DoWhileFalse}{
  \bigstep{\strip{e_{in}}{\targ}{\sigma}}{\spair{\targ'}{\sigma'}} \andalso
  \bigstep{\strip{e_{pred\_out}}{\targ'}{\sigma'}}{\spair{[\bot, v]}{\sigma''}}
}
{\bigstep{
    \strip{\text{DoWhile }e_{in}\ e_{pred\_out}}{\targ}{\sigma}
  }{
    \spair{v}{\sigma''}
}}


\inferrule{E-DoWhileTrue}{
  \bigstep{\strip{e_{in}}{\targ}{\sigma}}{\spair{\targ'}{\sigma'}} \andalso
  \bigstep{\strip{e_{pred\_out}}{\targ'}{\sigma'}}{\spair{[\top, \targ'']}{\sigma''}} \andalso
  \bigstep{\strip{\text{DoWhile } e_{in}\ e_{pred\_out}}{\targ''}{\sigma''}}{\spair{v}{\sigma'''}}
}
{\bigstep{
    \strip{\text{DoWhile }e_{in}\ e_{pred\_out}}{\targ}{\sigma}
  }{
    \spair{v}{\sigma'''}
}}



  %% \caption{expr big-step semantics.}
%% \end{figure}

%% \begin{figure}%{\linewidth}
%%   \begin{align*}
%%     \denote{ \mathsf{Set} ~ ts } &= ts
%%     & % \\
%%     \denote{ \mathsf{Filter} ~ \mathit{filter} ~ \W } &=
%%     \set{t \in \denote{ \W }}{\denote{ \mathit{filter} } (t) = true}
%%     \\
%%     \denote{ \mathsf{Union} ~ \W_1 ~ \W_2 } &=
%%     \denote{ \W_1 }~\cup~\denote{ \W_2 } \hspace{8mm}
%%     & % \\
%%     \denote{ \mathsf{Plug} ~ \W_1 ~ \mathit{tgt} ~ \W_2 } &=
%%       \bigcup_{e \in \denote{\W_1}}
%%       \denote{ \plugsexp ~ e ~ \mathit{tgt} ~ \W_2 }
%%   \end{align*}
%%   \begin{align*}
%%     \denote{ \plugsexp ~ (Atom ~ s) ~ \mathit{s} ~ \W } &=
%%     \denote{ \W }
%%     \\
%%     \denote{ \plugsexp ~ (Atom ~ s) ~ \mathit{tgt} ~ \W } &=
%%     \{Atom ~ s\} ~\mathsf{when} ~ s \neq \mathit{tgt}
%%     \\
%%     \denote{ \plugsexp ~ (List ~ s_1 ~ \ldots ~ s_n) ~ \mathit{tgt} ~ \W } &=
%%     \set{List ~ t_1 ~ \ldots ~ t_n}{t_i \in \denote{ \plugsexp ~ s_i ~ \mathit{tgt} ~ \W }}
%%   \end{align*}
%%   \caption{\enumo workload semantics.}
%%   \label{fig:denote-workload}
%% \end{figure}

%% \begin{figure}%{\linewidth}
%%   \begin{align*}
%%     \denote{\mathsf{MetricLt} ~ M ~ n}(t) &= \denote{ M } (t) < n  &
%%     \denote{\mathsf{Contains} ~ p}(t) &=
%%       \exists \sigma, \sigma(p) \in \mathsf{subterms}(t) \\
%%       % includes(t, p) \\
%%     \denote{\mathsf{MetricEq} ~ M ~ n}(t) &= \denote{ M } (t) = n  &
%%     \denote{\mathsf{Canon} ~ \vec{a} ~ }(t) &= canon(\vec{a}, t) == t
%%   \end{align*}
%% \end{figure}


%% \inferrule{T-While}{\texttt{$\Gamma$ $\vdash$ t$_1$ : Bool} \andalso \texttt{$\Gamma$ $\vdash$ t$_2$ : True}}{\texttt{$\Gamma$ $\vdash$ while t$_1$ do t$_2$: True}}

