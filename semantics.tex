\begin{figure}%{\linewidth}
  \begin{minipage}[t]{0.45\linewidth}
    \begin{grammar}
      <basetype> ::= IntT \alt BoolT

      <type> ::= <basetype> \alt PointerT <type> \alt TupleT <basetype>*

      <bool> ::= $\top$ \alt $\bot$

      <order> ::= Parallel \alt Sequential

      <function> ::= Function <type> <expr>

      <assumption> ::= InLet <expr>
      \alt InLoop <expr> <expr>
      \alt InFunc <function>
      \alt InSwitch <\N> <expr>
      \alt InIf <bool> <expr>
      \alt AfterWrite <expr> <expr>
    \end{grammar}
  \end{minipage}\hfill%
  \begin{minipage}[t]{0.5\linewidth}
    \begin{grammar}
      <expr> ::= Arg <type>
      \alt Int <\N>
      \alt Bool <bool>
      \alt Empty
      \alt Add <expr> <expr>
      \alt Sub <expr> <expr>
      \alt Mul <expr> <expr>
      \alt LessThan <expr> <expr>
      \alt And <expr> <expr>
      \alt Or <expr> <expr>
      \alt Write <expr> <expr>
      \alt PtrAdd <expr> <expr>
      \alt Not <expr>
      \alt Print <expr>
      \alt Read <expr>
      \alt Get <expr> <\N>
      \alt Alloc <expr> <type>
      \alt Call <function> <expr>
      \alt Single <expr>
      \alt Concat <order> <expr> <expr>
      \alt Switch <expr> <expr>*
      \alt If <expr> <expr> <expr>
      \alt Let <expr> <expr>
      \alt DoWhile <expr> <expr>
      \alt Assume <assumption> <expr>
    \end{grammar}%
    \end{minipage}%
  \caption{expr abstract syntax.}
\end{figure}

\newcommand{\inferax}[2]{\infrule[#1]{\mbox{}}{\mbox{$#2$}}}
\renewcommand{\inferrule}[3]{\infrule[#1]{\mbox{$#2$}}{\mbox{$#3$}}}
\newcommand{\bigstep}[2]{#1 \Downarrow #2}
\newcommand{\ang}[1]{\langle #1 \rangle}
\newcommand{\spair}[2]{\ang{#1, #2}}
\newcommand{\strip}[3]{\ang{#1, #2, #3}}

\newcommand{\targ}{\alpha}
\newcommand{\tmem}{\sigma}

\newcommand{\uop}[2]{\operatorname{#1}\ #2}
\newcommand{\bop}[3]{\operatorname{#1}\ #2\ #3}
\newcommand{\trop}[4]{\operatorname{#1}\ #2\ #3\ #4}

% (expression, arg, state) to (value, state)
\newcommand{\easvs}[5]{\bigstep{\strip{#1}{#2}{#3}}{\spair{#4}{#5}}}

% "definition" version of easvs
\newcommand{\easvsd}[5]{\easvs{#1}{#2}{#3}{#4}{#5}}

\newcommand{\append}[2]{#1\ \texttt{+\hspace{-1pt}+}\ #2}

\newcommand{\semanticsrules}{

\inferax{E-Num}{\easvsd{\uop{Num}{n}}{\targ}{\tmem}{n}{\tmem}}

\inferax{E-Bool}{\easvsd{\uop{Bool}{b}}{\targ}{\tmem}{b}{\tmem}}

\inferrule{E-Add}{
  \easvs{e_1}{\targ}{\tmem}{v_1}{\tmem'} \andalso
  \easvs{e_2}{\targ}{\tmem'}{v_2}{\tmem''}}
{\easvsd
  {\bop{Add}{e_1}{e_2}}{\targ}{\tmem}
  {v_1 + v_2}{\tmem''}}

\inferrule{E-IfTrue}{
  \easvs{e_c}{\targ}{\tmem}{\top}{\tmem'} \andalso
  \easvs{e_t}{\targ}{\tmem'}{v_t}{\tmem''}}
{\easvsd
  {\trop{If}{e_c}{e_t}{e_e}}{\targ}{\tmem}
  {v_t}{\tmem''}}

\inferrule{E-IfFalse}{
  \easvs{e_c}{\targ}{\tmem}{\bot}{\tmem'} \andalso
  \easvs{e_e}{\targ}{\tmem'}{v_e}{\tmem''}}
{\easvsd
  {\trop{If}{e_c}{e_t}{e_e}}{\targ}{\tmem}
  {v_e}{\tmem''}}

\inferrule{E-Switch}{
  \easvs{e_{pred}}{\targ}{\tmem}{i}{\sigma'} \andalso
  \easvs{e_i}{\targ}{\sigma'}{v}{\sigma''}}
{\easvsd
  {\bop{Switch}{e_{pred}}{(e_1, \dots, e_n)}}{\targ}{\tmem}
  {v}{\tmem''}}

\inferrule{E-Let}{
  \easvs{e_{in}}{\targ}{\tmem}{v_{in}}{\tmem'} \andalso
  \easvs{e_{out}}{v_{in}}{\tmem'}{v_{out}}{\tmem''}}
{\easvsd
  {\bop{Let}{e_{in}}{e_{out}}}{\targ}{\tmem}
  {v_{out}}{\tmem''}}

\inferrule{E-Print}{
  \easvs{e}{\targ}{\tmem}{v}{(M,L)}}
{\easvsd
  {\uop{Print}{e}}{\targ}{\tmem}
  {[]}{(M,\append{L}{v})}}

\inferrule{E-Read}{
  \easvs{e}{\targ}{\tmem}{v}{(M,L)}}
{\easvsd
  {\uop{Read}{e}}{\targ}{\tmem}
  {M[v]}{(M,L)}}

\inferrule{E-Alloc}{
  \easvs{e}{\targ}{\tmem}{n}{(M,L)} \andalso
  (M', p) = \operatorname{malloc}(M, n * \operatorname{sizeof}(\tau))}
{\easvsd
  {\bop{Alloc}{e}{\tau}}{\targ}{\tmem}
  {p}{(M',L)}}

\inferrule{E-Write}{
  \easvs{e_p}{\targ}{\tmem}{v_p}{\tmem'} \andalso
  \easvs{e_d}{\targ}{\tmem'}{v_d}{(M,L)}}
{\easvsd
  {\bop{Write}{e_p}{e_d}}{\targ}{\tmem}
  {[]}{(M[v_p\to v_d], L)}}

\inferrule{E-Single}{
  \easvs{e}{\targ}{\tmem}{v}{\tmem'}}
{\easvsd
  {\uop{Single}{e}}{\targ}{\tmem}
  {[v]}{\tmem'}}

\inferrule{E-ConcatSeq}{
  \easvs{e_1}{\targ}{\tmem}{v_1}{\tmem'} \andalso
  \easvs{e_2}{\targ}{\tmem'}{v_2}{\tmem''}}
{\easvsd
  {\bop{Concat\ Sequential}{e_1}{e_2}}{\targ}{\tmem}
  {\append{v_1}{v_2}}{\tmem''}}

\inferrule{E-DoWhileFalse}{
  \easvs{e_{in}}{\targ}{\tmem}{\targ'}{\tmem'} \andalso
  \easvs{e_{pred\_out}}{\targ'}{\tmem'}{[\bot,v]}{\tmem''}}
{\easvsd
  {\bop{DoWhile}{e_{in}}{e_{out}}}{\targ}{\tmem}
  {v}{\tmem''}}

\inferrule{E-DoWhileTrue}{
  \easvs{e_{in}}{\targ}{\tmem}{\targ'}{\tmem'} \andalso
  \easvs{e_{pred\_out}}{\targ'}{\tmem'}{[\top,\targ'']}{\tmem''} \andalso
  \easvs{\bop{DoWhile}{e_{in}}{e_{pred\_out}}}{\targ''}{\tmem''}{v}{\tmem'''}}
{\easvsd
  {\bop{DoWhile}{e_{in}}{e_{pred\_out}}}{\targ}{\tmem}
  {v}{\tmem'''}}

\inferrule{E-AssumeInLet}{
  \easvs{e}{\targ}{\tmem}{v}{\tmem'} \andalso
  \exists\ \targ_2, \tmem_2, \tmem_3 .\;
    \easvs{e_{in}}{\targ_2}{\tmem_2}{\targ}{\tmem_3}}
{\easvsd
  {\bop{Assume}{(\uop{InLet}{e_{in}})}{e}}{\targ}{\tmem}
  {v}{\tmem'}}

\inferrule{E-AssumeAfterWrite}{
  \easvs{e}{\targ}{\tmem}{v}{\tmem'} \andalso
  \exists\ \targ_2, v_2, \tmem_2 .\;
    \easvs{\bop{Write}{e_p}{e_d}}{\targ_2}{\tmem_2}{v_2}{\tmem_3}}
{\easvsd
  {\bop{Assume}{(\bop{AfterWrite}{e_p}{e_d})}{e}}{\targ}{\tmem}
  {v}{\tmem'}}


}


\clearpage
\newpage

\subsection*{Big-step operational semantics}

$\bigstep{\strip{e}{\targ}{\tmem}}{\spair{v}{\tmem'}}$ means: with argument $\targ$ and state $\tmem$, $e$ evaluates to $v$ and the resulting state is $\tmem'$.

A state is pair $(M, L)$, containing memory and a print log.

\semanticsrules

\newpage

\subsection*{Denotational semantics}

\renewcommand{\denote}[1]{\left\llbracket #1 \right\rrbracket}
\newcommand{\denotef}[2]{\denote{#1}\left(#2\right)}

% (expression, arg, state) to (value, state)
\renewcommand{\easvs}[5]{\denotef{#1}{#2, #3} = (#4, #5)}
\renewcommand{\easvsd}[5]{\denotef{#1}{#2, #3} \triangleq (#4, #5)}

\semanticsrules

\newpage
